[{"id":0,"href":"/docs/2025-2026/meetings/1-13-26/","title":"1-13-26","section":"Meetings","content":"Work done# Working on creating two versions of the code that will then come together One that is just the bare essentials for SAR filming- dont want to overcomplicate and run into issues\nThen can be easily extended with CAN and LED features\nLED features could probably be added to this bare-bones code, but we need a protoboard and wiring for this "},{"id":1,"href":"/docs/2025-2026/meetings/1-7-26/","title":"1-7-26","section":"Meetings","content":"Meeting 1/7/26# Embedded progress# Have taken a look at the old code and have started to modify it for this year Removed stepper motor library Removed math library - will see if we need to readd this for calculating the amount to be put into each tube My Questions# What type of ESP32 are we using\nESP32-S3?\nOr are we just using the ESP32 devkit\nWe are planning on using the ESP32 DevKit V1 It is probably this one TODO# Import astravican file into the project\nDefine motors Find out how to call them LED control\nDetermine what type of modes the Define servos\n"},{"id":2,"href":"/docs/2025-2026/biosensor/2025-bio-code/","title":"2025 Biosensor Code","section":"Biosensor","content":"Use this code for reference as needed.\n/** * @file DigitMainMCU.h * @author David Sharpe (ds0196@uah.edu) * @brief Digit PCB; controls end effector, wrist, and now FAERIE; attaches to end of arm * */ #pragma once #if defined(ESP32) \u0026amp;\u0026amp; !defined(ARDUINO_ADAFRUIT_FEATHER_ESP32_V2) //------------------------------------------------------------------------------------------------// // DOIT ESP32 Devkit V1 (URC 2025, Digit+FAERIE V2) //------------------------------------------------------------------------------------------------// // Comms # define CAN_RX 27 # define CAN_TX 14 // Linear actuator # define LINAC_RIN 19 # define LINAC_FIN 18 // End Effector # define MOTOR_IN1 33 # define MOTOR_IN2 25 # define MOTOR_FAULT 4 # define LASER_NMOS 23 // same for faerie // ADC # define PIN_VDIV_5V 35 # define PIN_VDIV_12V 36 # define PIN_VDIV_BATT 39 // FAERIE # define SPARK_PWM 26 // Misc # define PIN_NEOPIXEL 13 // LSS # define LSS_SERIAL Serial2 #elif defined(ARDUINO_ADAFRUIT_FEATHER_ESP32_V2) //------------------------------------------------------------------------------------------------// // Feather ESP32 (URC 2025, Digit V1) //------------------------------------------------------------------------------------------------// // Comms # define CAN_RX 14 # define CAN_TX 32 // Linear actuator # define LINAC_RIN 12 # define LINAC_FIN 13 // End Effector # define MOTOR_FAULT 5 # define MOTOR_IN2 19 # define MOTOR_IN1 21 # define LASER_NMOS 25 // ADC # define PIN_VDIV_5V 34 # define PIN_VDIV_12V 39 # define PIN_VDIV_BATT 36 // Misc # define MCU_DEBUG 4 // Lynxmotion Smart Servo # define LSS_SERIAL Serial1 #elif defined(CORE_TEENSY) //------------------------------------------------------------------------------------------------// // Teensy 4.x (URC 2024) //------------------------------------------------------------------------------------------------// //------// // Pins // //------// // DC on/off control for laser on end effector # define PIN_LASER 8 // PWM control for REV motor that opens/closes end effector # define PIN_EF_MOTOR 19 //-----------// // Constants // //-----------// # define COMMS_UART Serial1 #endif [ 104][E][ESP32PWM.cpp:135] allocatenext(): [ESP32PWM] ERROR All PWM timers allocated! Can\u0026#39;t accomodate 50.000 Hz /** * @file main.cpp * @author Jack Schumacher (js0342@uah.edu) * @author David Sharpe (ds0196@uah.edu) * @brief ASTRA Biosensor Citadel embedded code * */ #include \u0026lt;Arduino.h\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;ESP32Servo.h\u0026gt; #include \u0026#34;AstraMisc.h\u0026#34; #include \u0026#34;AstraVicCAN.h\u0026#34; #include \u0026#34;AstraREVCAN.h\u0026#34; #include \u0026#34;AstraMotors.h\u0026#34; // Remove to disable the boards inbuilt LED blinking #define BLINK #define CAN_TX 34 #define CAN_RX 35 #define FAN_MOTOR_ID 1 // TODO: Needs to be confirmed that this is the correct CAN ID #define REV_PWM_MIN 1000 // us -1.0 duty #define REV_PWM_MAX 2000 // us 1.0 duty #define SPARK_PWM 26 #define COMMS_UART Serial // To/from USB for debugging bool ledState = false; // Defined servos (3 for valves, 3 for distributors, 3 for chemicals) Servo valve1, valve2, valve3, distributor1, distributor2, distributor3, chemical1, chemical2, chemical3; Servo *servoReference[9] = {\u0026amp;valve1, \u0026amp;valve2, \u0026amp;valve3, \u0026amp;distributor1, \u0026amp;distributor2, \u0026amp;distributor3, \u0026amp;chemical1, \u0026amp;chemical2, \u0026amp;chemical3}; int currentServoPos[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0}; int targetServoPos[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0}; unsigned long lastServoMoveTime = 0; int servoSpeed = 10; // Uses servo steps to determine speed long lastWiggle = 0; // For PWM servos unsigned long lastAccel = 0; unsigned long lastHB = 0; int heartBeatNum = 1; unsigned long lastCtrlCmd = 0; unsigned long lastMotorStatus = 0; // Control the NEO550 functioning as the fan motor Servo fanMotor; void loop2(void *pvParameters) { while (true) { CAN_sendHeartbeat(heartBeatNum); heartBeatNum++; if (heartBeatNum \u0026gt; 4) { heartBeatNum = 1; } delay(5); } } // Declarations void Stop(); void setup() { // Servo Pins: 13,14,18,19,22,23,25,26,27 // Actual pins From bottom facing the USB C port- 25,13,27,18,22 // Top Left: 14,26,19,23 (last 2 on the top are not used) Serial.begin(SERIAL_BAUD); // Valves are on top of the unit valve1.attach(10); valve2.attach(11); valve3.attach(12); // Distributors are on each of the pieces that hang down distributor1.attach(7); distributor2.attach(8); distributor3.attach(9); // Chemical servos are in the back of the unit (the larger servos) chemical1.attach(4); chemical2.attach(5); chemical3.attach(6); fanMotor.attach(SPARK_PWM, REV_PWM_MIN, REV_PWM_MAX); if (ESP32Can.begin(TWAI_SPEED_1000KBPS, CAN_TX, CAN_RX)) Serial.println(\u0026#34;CAN bus started!\u0026#34;); else Serial.println(\u0026#34;CAN bus failed!\u0026#34;); // // TODO: Confirm that this is working- is CAN receiving a heartbeat? // // Pin the CAN heartbeat task to core // xTaskCreatePinnedToCore( // loop2, // Function to implement the task // \u0026#34;loop2\u0026#34;, // Name of the task // 1000, // Stack size in bytes // NULL, // Task input parameter // 0, // Priority of the task // NULL, // Task handle. // 0 // Core where the task should run // ); } void loop() { if (millis() - lastServoMoveTime \u0026gt;= servoSpeed) { lastServoMoveTime = millis(); for (int i = 0; i \u0026lt; 9; i++) { if (currentServoPos[i] \u0026lt; targetServoPos[i]) { currentServoPos[i]++; servoReference[i]-\u0026gt;write(currentServoPos[i]); } else if (currentServoPos[i] \u0026gt; targetServoPos[i]) { currentServoPos[i]--; servoReference[i]-\u0026gt;write(currentServoPos[i]); } } } if (millis() - lastWiggle \u0026gt; 500) { // Move Servos ID 2-5 (The Distributor Servos) back and fourth to distribute the dirt into the tubes lastWiggle = millis(); for (int i = 3; i \u0026lt; 6; i++) { if (currentServoPos[i]) { targetServoPos[i] = (targetServoPos[i] == 0 ? 180 : 0); } } } // Serial commands if (Serial.available()) { String input = Serial.readStringUntil(\u0026#39;\\n\u0026#39;); Serial.println(input); input.trim(); // Remove preceding and trailing whitespace std::vector\u0026lt;String\u0026gt; args = {}; // Initialize empty vector to hold separated arguments parseInput(input, args); // Separate `input` by commas and place into args vector args[0].toLowerCase(); // Make command case-insensitive String command = args[0]; // To make processing code more readable if (command == \u0026#34;ping\u0026#34;) { Serial.println(\u0026#34;pong\u0026#34;); } else if (command == \u0026#34;time\u0026#34;) { Serial.println(millis()); } else if (command == \u0026#34;led\u0026#34;) // This command will not work when using boards that do not have a inbuilt LED (i.e. the ESP32 Dev Module 1) { digitalWrite(LED_BUILTIN, !ledState); ledState = !ledState; } else if (args[0] == \u0026#34;can_relay_tovic\u0026#34;) { vicCAN.relayFromSerial(args); } else if (args[0] == \u0026#34;can_relay_mode\u0026#34;) { if (args[1] == \u0026#34;on\u0026#34;) { vicCAN.relayOn(); } else if (args[1] == \u0026#34;off\u0026#34;) { vicCAN.relayOff(); } } // Servos are numbered 1-9 // To use: servo,[servo number],[degrees] else if (args[0] == \u0026#34;servo\u0026#34;) { int servo_id = args[1].toInt() - 1; // Get servo id int servo_angle = args[2].toInt(); if (servo_id \u0026gt;= 0 \u0026amp;\u0026amp; servo_id \u0026lt; 9) { // Validate the servo values - Servo IDs 6-9 (the chemical servos) should only move 60 degrees to prevent overextension and other issues if (servo_id \u0026gt;= 1 \u0026amp;\u0026amp; servo_id \u0026lt;= 3) { targetServoPos[servo_id] = (servo_angle \u0026lt;= 60) ? servo_angle : 60; } // Other servos can move the full 180 degrees else { targetServoPos[servo_id] = servo_angle; } } } // Commands that move all servos in a group // val = valve servos // dist = distributor servos // chem = chemical servos // all = all servos (might cause power issues) else if (args[0] == \u0026#34;val\u0026#34;) { valve1.write(args[1].toInt()); valve2.write(args[1].toInt()); valve3.write(args[1].toInt()); } else if (args[0] == \u0026#34;dist\u0026#34;) { distributor1.write(args[1].toInt()); distributor2.write(args[1].toInt()); distributor3.write(args[1].toInt()); } else if (args[0] == \u0026#34;chem\u0026#34;) { if (args[1].toInt() \u0026gt;= 55) { chemical1.write(55); chemical2.write(55); chemical3.write(55); } else { chemical1.write(args[1].toInt()); chemical2.write(args[1].toInt()); chemical3.write(args[1].toInt()); } } else if (args[0] == \u0026#34;all\u0026#34;) { valve1.write(args[1].toInt()); valve2.write(args[1].toInt()); valve3.write(args[1].toInt()); distributor1.write(args[1].toInt()); distributor2.write(args[1].toInt()); distributor3.write(args[1].toInt()); if (args[1].toInt() \u0026gt;= 55) { chemical1.write(55); chemical2.write(55); chemical3.write(55); } else { chemical1.write(args[1].toInt()); chemical2.write(args[1].toInt()); chemical3.write(args[1].toInt()); } } } // CAN if (vicCAN.readCan()) { const uint8_t commandID = vicCAN.getCmdId(); static std::vector\u0026lt;double\u0026gt; canData; vicCAN.parseData(canData); Serial.print(\u0026#34;VicCAN: \u0026#34;); Serial.print(commandID); Serial.print(\u0026#34;; \u0026#34;); if (canData.size() \u0026gt; 0) { for (const double \u0026amp;data : canData) { Serial.print(data); Serial.print(\u0026#34;, \u0026#34;); } } Serial.println(); // Misc CAN commands if (commandID == CMD_PING) { vicCAN.respond(1); // \u0026#34;pong\u0026#34; Serial.println(\u0026#34;Received ping over CAN\u0026#34;); } // Takes a servo ID between 1 and 9 as well as the angle that the commanded servo should move to else if (commandID == CMD_PWMSERVO_SET_DEG) { if (canData.size() == 2 \u0026amp;\u0026amp; canData[0] \u0026gt; 0 \u0026amp;\u0026amp; canData[0] \u0026lt; 9) { unsigned servoId = static_cast\u0026lt;unsigned\u0026gt;(canData[0]); targetServoPos[servoId - 1] = static_cast\u0026lt;int\u0026gt;(canData[1]); } } // TODO: Add parser for REV command // Motor control safety timeout- if no command is received in 2 seconds, shut off the NEO if (millis() - lastCtrlCmd \u0026gt; 2000) { lastCtrlCmd = millis(); fanMotor.write(0); } else if (commandID == CMD_REV_STOP) { lastCtrlCmd = millis(); fanMotor.write((REV_PWM_MIN + REV_PWM_MAX) / 2); } // Converts duty cycle input into writeMicroseconds range of the NEO else if (commandID == CMD_REV_SET_DUTY) { if (canData.size() == 1) { lastCtrlCmd = millis(); int value = map_d(canData[0] / 100.0, -1.0, 1.0, REV_PWM_MIN, REV_PWM_MAX); fanMotor.writeMicroseconds(value); Serial.print(\u0026#34;Setting REV duty to \u0026#34;); Serial.println(value); } } } }"},{"id":3,"href":"/docs/two-month/ros2/about-ros/","title":"About ROS","section":"ROS2","content":"Make Sure to use ROS2 Humble Hawksbill with Ubuntu 22.04 (preferably Ubuntu 22.04 LTS)\nROS2 Humble Hawksbill Documentation Download Ubuntu 22.04 LTS (Desktop recommended) "},{"id":4,"href":"/docs/2025-2026/biosensor/adafruit-pca9685-pwm/","title":"Adafruit PCA9685 PWM","section":"Biosensor","content":"Snippets# Adafruit example# From: Adafruit GitHub\n/*************************************************** This is an example for our Adafruit 16-channel PWM \u0026amp; Servo driver Servo test - this will drive 8 servos, one after the other on the first 8 pins of the PCA9685 Pick one up today in the adafruit shop! ------\u0026gt; http://www.adafruit.com/products/815 These drivers use I2C to communicate, 2 pins are required to interface. Adafruit invests time and resources providing this open source code, please support Adafruit and open-source hardware by purchasing products from Adafruit! Written by Limor Fried/Ladyada for Adafruit Industries. BSD license, all text above must be included in any redistribution ****************************************************/ #include \u0026lt;Wire.h\u0026gt; #include \u0026lt;Adafruit_PWMServoDriver.h\u0026gt; // called this way, it uses the default address 0x40 Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(); // you can also call it with a different address you want //Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x41); // you can also call it with a different address and I2C interface //Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x40, Wire); // Depending on your servo make, the pulse width min and max may vary, you // want these to be as small/large as possible without hitting the hard stop // for max range. You\u0026#39;ll have to tweak them as necessary to match the servos you // have! #define SERVOMIN 150 // This is the \u0026#39;minimum\u0026#39; pulse length count (out of 4096) #define SERVOMAX 600 // This is the \u0026#39;maximum\u0026#39; pulse length count (out of 4096) #define USMIN 600 // This is the rounded \u0026#39;minimum\u0026#39; microsecond length based on the minimum pulse of 150 #define USMAX 2400 // This is the rounded \u0026#39;maximum\u0026#39; microsecond length based on the maximum pulse of 600 #define SERVO_FREQ 50 // Analog servos run at ~50 Hz updates // our servo # counter uint8_t servonum = 0; void setup() { Serial.begin(9600); Serial.println(\u0026#34;8 channel Servo test!\u0026#34;); pwm.begin(); /* * In theory the internal oscillator (clock) is 25MHz but it really isn\u0026#39;t * that precise. You can \u0026#39;calibrate\u0026#39; this by tweaking this number until * you get the PWM update frequency you\u0026#39;re expecting! * The int.osc. for the PCA9685 chip is a range between about 23-27MHz and * is used for calculating things like writeMicroseconds() * Analog servos run at ~50 Hz updates, It is importaint to use an * oscilloscope in setting the int.osc frequency for the I2C PCA9685 chip. * 1) Attach the oscilloscope to one of the PWM signal pins and ground on * the I2C PCA9685 chip you are setting the value for. * 2) Adjust setOscillatorFrequency() until the PWM update frequency is the * expected value (50Hz for most ESCs) * Setting the value here is specific to each individual I2C PCA9685 chip and * affects the calculations for the PWM update frequency. * Failure to correctly set the int.osc value will cause unexpected PWM results */ pwm.setOscillatorFrequency(27000000); pwm.setPWMFreq(SERVO_FREQ); // Analog servos run at ~50 Hz updates delay(10); } // You can use this function if you\u0026#39;d like to set the pulse length in seconds // e.g. setServoPulse(0, 0.001) is a ~1 millisecond pulse width. It\u0026#39;s not precise! void setServoPulse(uint8_t n, double pulse) { double pulselength; pulselength = 1000000; // 1,000,000 us per second pulselength /= SERVO_FREQ; // Analog servos run at ~60 Hz updates Serial.print(pulselength); Serial.println(\u0026#34; us per period\u0026#34;); pulselength /= 4096; // 12 bits of resolution Serial.print(pulselength); Serial.println(\u0026#34; us per bit\u0026#34;); pulse *= 1000000; // convert input seconds to us pulse /= pulselength; Serial.println(pulse); pwm.setPWM(n, 0, pulse); } void loop() { // Drive each servo one at a time using setPWM() Serial.println(servonum); for (uint16_t pulselen = SERVOMIN; pulselen \u0026lt; SERVOMAX; pulselen++) { pwm.setPWM(servonum, 0, pulselen); } delay(500); for (uint16_t pulselen = SERVOMAX; pulselen \u0026gt; SERVOMIN; pulselen--) { pwm.setPWM(servonum, 0, pulselen); } delay(500); // Drive each servo one at a time using writeMicroseconds(), it\u0026#39;s not precise due to calculation rounding! // The writeMicroseconds() function is used to mimic the Arduino Servo library writeMicroseconds() behavior. for (uint16_t microsec = USMIN; microsec \u0026lt; USMAX; microsec++) { pwm.writeMicroseconds(servonum, microsec); } delay(500); for (uint16_t microsec = USMAX; microsec \u0026gt; USMIN; microsec--) { pwm.writeMicroseconds(servonum, microsec); } delay(500); servonum++; if (servonum \u0026gt; 7) servonum = 0; // Testing the first 8 servo channels }Usage examples# // 1. Define the \u0026#34;Pins\u0026#34; (Channels) const uint8_t BASE = 0; const uint8_t ELBOW = 1; const uint8_t WRIST = 2; const uint8_t CLAW = 3; // 2. Put them in an array so the loop knows which ones to talk to uint8_t myServos[] = {BASE, ELBOW, WRIST, CLAW}; int totalServos = 4; void setup() { pwm.begin(); pwm.setPWMFreq(60); } void loop() { // 3. Loop through the array for (int i = 0; i \u0026lt; totalServos; i++) { uint8_t currentPin = myServos[i]; // This pulls 0, then 1, then 2... // Command the specific pin pwm.setPWM(currentPin, 0, 300); delay(200); }void loop() { // Move the base to 90 degrees setServoAngle(BASE_SERVO, 90); // Open the claw setServoAngle(CLAW_SERVO, 10); delay(1000); // Close the claw setServoAngle(CLAW_SERVO, 170); delay(1000); } // Helper function to handle the degree-to-pulse math void setServoAngle(uint8_t channel, int angle) { uint16_t pulse = map(angle, 0, 180, SERVOMIN, SERVOMAX); pwm.setPWM(channel, 0, pulse); }"},{"id":5,"href":"/docs/2025-2026/biosensor/can-commands/","title":"CAN commands","section":"Biosensor","content":"Citadel CAN commands# Starting CAN relay mode# can_relay_mode,onPing command# can_relay_tovic,citadel,1Motor Movement# Servo Movement# Structure:# can_relay_tovic,citadel,40,[group],[angle1],[angle2],[angle3] can_relay_tovic - call the can_relay_tovic command citadel - call the citadel mcu 40 - CAN command Group valves (1,2,3) distributor (1,2,3) chemical (1,2,3) Angles Angle to move valve servos Angle to move distributor servos Angle to move chemical servos Example:# can_relay_tovic,citadel,40,1,30,30,30REV/NEO 550 motor movement# Structure# can_relay_tovic,citadel,19,[speed] citadel - call the citadel MCU 19 - CAN command Speed - speed that the motor should run at Example# can_relay_tovic,19,20Other Commands# Ping# Expected response: pong\ncan_relay_tovic,citadel,CMD_PINGCMD_REV_STOP# Expected response: stop REV motor\ncan_relay_tovic,citadel,CMD_REV_STOP"},{"id":6,"href":"/docs/2025-2026/biosensor/embedded-summary/","title":"Embedded summary","section":"Biosensor","content":"Summary# 9 servos One NEO 550 functioning as the fan motor Resources# Equipment Links\nESP-32-S3 (3 pack)\nESP-32 Devkit V1\nESP-32 Devkit V1 GPIO/PWM pins# Avaliable Pins with PWM, IO and no board functions# 14 27 26 25 33 32 23 22 21 19 18 5 17 16 4 ESP-32 S3 pins# We are currently not using this board due to PWM limitations. These pins are in case this issue can be resolved\nValve1: 1\rValve2: 2\rValve3: 42\rDistributor1: 41\rDistributor2: 40\rDistributor3: 39 - Commented out because of S3 timing issue\rChemical1: 38\rChemical2: 37\rChemical3: 36"},{"id":7,"href":"/docs/2025-2026/biosensor/prototypes/esp32s3/","title":"ESP32-S3","section":"Prototypes","content":"ESP32 S3 pinout# Valve1: 1\nValve2: 2\nValve3: 42\nDistributor1: 41\nDistributor2: 40\nDistributor3: 39 - Commented out because of S3 timing issue\nChemical1: 38\nChemical2: 37\nChemical3: 36\nESP32 S3 with many servos links# https://esp32.com/viewtopic.php?t=9271 "},{"id":8,"href":"/docs/two-month/ros2/installing-ros2-humble/","title":"Installing ROS2 Humble","section":"ROS2","content":" It is recommended to Install ROS2 on Linux, specifically Ubuntu 22.04 (LTS).\nReference the ROS2 Humble installation instructions It is recommended to use the Debian package(s) to install ROS2 on your system It is recommended to install ros-humble-desktop, not the other versions: sudo apt install ros-humble-desktop"},{"id":9,"href":"/docs/two-month/sensors/working-with-the-bnp3xx/","title":"Working with the BMP388","section":"Sensors","content":"Important Links# Adafruit BMP3xx (BMP388\u0026amp;BMP390) Datasheet (it\u0026rsquo;s one datasheet for both) Adafruit BMP3xx GitHub (example code)\nExample code# Example code from Manufacturer# /*************************************************************************** This is a library for the BMP3XX temperature \u0026amp; pressure sensor Designed specifically to work with the Adafruit BMP388 Breakout ----\u0026gt; http://www.adafruit.com/products/3966 These sensors use I2C or SPI to communicate, 2 or 4 pins are required to interface. Adafruit invests time and resources providing this open source code, please support Adafruit and open-source hardware by purchasing products from Adafruit! Written by Limor Fried \u0026amp; Kevin Townsend for Adafruit Industries. BSD license, all text above must be included in any redistribution ***************************************************************************/ #include \u0026lt;Wire.h\u0026gt; #include \u0026lt;SPI.h\u0026gt; #include \u0026lt;Adafruit_Sensor.h\u0026gt; #include \u0026#34;Adafruit_BMP3XX.h\u0026#34; // Need to modify these pins #define BMP_SCK 13 #define BMP_MISO 12 #define BMP_MOSI 11 #define BMP_CS 10 #define SEALEVELPRESSURE_HPA (1013.25) Adafruit_BMP3XX bmp; void setup() { Serial.begin(115200); while (!Serial); Serial.println(\u0026#34;Adafruit BMP388 / BMP390 test\u0026#34;); if (!bmp.begin_I2C()) { // hardware I2C mode, can pass in address \u0026amp; alt Wire //if (! bmp.begin_SPI(BMP_CS)) { // hardware SPI mode //if (! bmp.begin_SPI(BMP_CS, BMP_SCK, BMP_MISO, BMP_MOSI)) { // software SPI mode Serial.println(\u0026#34;Could not find a valid BMP3 sensor, check wiring!\u0026#34;); while (1); } // Set up oversampling and filter initialization bmp.setTemperatureOversampling(BMP3_OVERSAMPLING_8X); bmp.setPressureOversampling(BMP3_OVERSAMPLING_4X); bmp.setIIRFilterCoeff(BMP3_IIR_FILTER_COEFF_3); bmp.setOutputDataRate(BMP3_ODR_50_HZ); } void loop() { if (! bmp.performReading()) { Serial.println(\u0026#34;Failed to perform reading :(\u0026#34;); return; } Serial.print(\u0026#34;Temperature = \u0026#34;); Serial.print(bmp.temperature); Serial.println(\u0026#34; *C\u0026#34;); Serial.print(\u0026#34;Pressure = \u0026#34;); Serial.print(bmp.pressure / 100.0); Serial.println(\u0026#34; hPa\u0026#34;); Serial.print(\u0026#34;Approx. Altitude = \u0026#34;); Serial.print(bmp.readAltitude(SEALEVELPRESSURE_HPA)); Serial.println(\u0026#34; m\u0026#34;); Serial.println(); delay(2000); }Link to example code on GitHub\n"},{"id":10,"href":"/docs/two-month/sensors/working-with-the-bno055/","title":"Working with the BNO055","section":"Sensors","content":"Helpful Links# Adafruit BNO055 GitHub page with examples BNO055 Datasheet\nExample code# Example code from the Manufacturer# #include \u0026lt;Wire.h\u0026gt; #include \u0026lt;Adafruit_Sensor.h\u0026gt; #include \u0026lt;Adafruit_BNO055.h\u0026gt; #include \u0026lt;utility/imumaths.h\u0026gt; /* This driver reads raw data from the BNO055 Connections =========== Connect SCL to analog 5 Connect SDA to analog 4 Connect VDD to 3.3V DC Connect GROUND to common ground History ======= 2015/MAR/03 - First release (KTOWN) */ // Reads sample data from BNO every 100 ms #define SAMPLERATE (100) // Check I2C device address and correct line below (by default address is 0x29 or 0x28) // id, address Adafruit_BNO055 bno = Adafruit_BNO055(-1, 0x28, \u0026amp;Wire); /**************************************************************************/ /* Arduino setup function (automatically called at startup) */ /**************************************************************************/ void setup(void) { Serial.begin(115200); while (!Serial) delay(10); // wait for serial port to open! /* Initialise the sensor */ if(!bno.begin()) { /* There was a problem detecting the BNO055 ... check your connections */ Serial.print(\u0026#34;Ooops, no BNO055 detected ... Check your wiring or I2C ADDR!\u0026#34;); while(1); } delay(1000); /* Display the current temperature */ int8_t temp = bno.getTemp(); Serial.print(\u0026#34;Current Temperature: \u0026#34;); Serial.print(temp); Serial.println(\u0026#34; C\u0026#34;); Serial.println(\u0026#34;\u0026#34;); bno.setExtCrystalUse(true); Serial.println(\u0026#34;Calibration status values: 0=uncalibrated, 3=fully calibrated\u0026#34;); } /**************************************************************************/ /* Arduino loop function, called once \u0026#39;setup\u0026#39; is complete (your own code should go here) */ /**************************************************************************/ void loop(void) { // Possible vector values can be: // - VECTOR_ACCELEROMETER - m/s^2 // - VECTOR_MAGNETOMETER - uT // - VECTOR_GYROSCOPE - rad/s // - VECTOR_EULER - degrees // - VECTOR_LINEARACCEL - m/s^2 // - VECTOR_GRAVITY - m/s^2 imu::Vector\u0026lt;3\u0026gt; euler = bno.getVector(Adafruit_BNO055::VECTOR_EULER); /* Display the floating point data */ Serial.print(\u0026#34;X: \u0026#34;); Serial.print(euler.x()); Serial.print(\u0026#34; Y: \u0026#34;); Serial.print(euler.y()); Serial.print(\u0026#34; Z: \u0026#34;); Serial.print(euler.z()); Serial.print(\u0026#34;\\t\\t\u0026#34;); /* // Quaternion data imu::Quaternion quat = bno.getQuat(); Serial.print(\u0026#34;qW: \u0026#34;); Serial.print(quat.w(), 4); Serial.print(\u0026#34; qX: \u0026#34;); Serial.print(quat.x(), 4); Serial.print(\u0026#34; qY: \u0026#34;); Serial.print(quat.y(), 4); Serial.print(\u0026#34; qZ: \u0026#34;); Serial.print(quat.z(), 4); Serial.print(\u0026#34;\\t\\t\u0026#34;); */ /* Display calibration status for each sensor. */ uint8_t system, gyro, accel, mag = 0; bno.getCalibration(\u0026amp;system, \u0026amp;gyro, \u0026amp;accel, \u0026amp;mag); Serial.print(\u0026#34;CALIBRATION: Sys=\u0026#34;); Serial.print(system, DEC); Serial.print(\u0026#34; Gyro=\u0026#34;); Serial.print(gyro, DEC); Serial.print(\u0026#34; Accel=\u0026#34;); Serial.print(accel, DEC); Serial.print(\u0026#34; Mag=\u0026#34;); Serial.println(mag, DEC); delay(BNO055_SAMPLERATE_DELAY_MS); }Link to example code on GitHub\n"},{"id":11,"href":"/docs/example/embedded/serial-command-parser/","title":"Serial Command Parser","section":"Embedded","content":"Serial Command Parser# From: https://forum.arduino.cc/t/parsing-serial-commands-programs-string-stuff/176213/2\nvoid handleSerial() { const int BUFF_SIZE = 32; // make it big enough to hold your longest command static char buffer[BUFF_SIZE+1]; // +1 allows space for the null terminator static int length = 0; // number of characters currently in the buffer if(Serial.available()) { char c = Serial.read(); if((c == \u0026#39;\\r\u0026#39;) || (c == \u0026#39;\\n\u0026#39;)) { // end-of-line received if(length \u0026gt; 0) { handleReceivedMessage(buffer); } length = 0; } else { if(length \u0026lt; BUFF_SIZE) { buffer[length++] = c; // append the received character to the array buffer[length] = 0; // append the null terminator } else { // buffer full - discard the received character } } } } void handleReceivedMessage(char *msg) { ... }"},{"id":12,"href":"/docs/two-month/resources/","title":"Resources","section":"Two-Month","content":"Repositories# Two-Month optimized code\n"}]