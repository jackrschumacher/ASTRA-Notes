<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Snippets# Adafruit example# From: Adafruit GitHub
/*************************************************** This is an example for our Adafruit 16-channel PWM &amp; Servo driver Servo test - this will drive 8 servos, one after the other on the first 8 pins of the PCA9685 Pick one up today in the adafruit shop! ------&gt; http://www.adafruit.com/products/815 These drivers use I2C to communicate, 2 pins are required to interface. Adafruit invests time and resources providing this open source code, please support Adafruit and open-source hardware by purchasing products from Adafruit! Written by Limor Fried/Ladyada for Adafruit Industries. BSD license, all text above must be included in any redistribution ****************************************************/ #include &lt;Wire.h&gt; #include &lt;Adafruit_PWMServoDriver.h&gt; // called this way, it uses the default address 0x40 Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(); // you can also call it with a different address you want //Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x41); // you can also call it with a different address and I2C interface //Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x40, Wire); // Depending on your servo make, the pulse width min and max may vary, you // want these to be as small/large as possible without hitting the hard stop // for max range. You&#39;ll have to tweak them as necessary to match the servos you // have! #define SERVOMIN 150 // This is the &#39;minimum&#39; pulse length count (out of 4096) #define SERVOMAX 600 // This is the &#39;maximum&#39; pulse length count (out of 4096) #define USMIN 600 // This is the rounded &#39;minimum&#39; microsecond length based on the minimum pulse of 150 #define USMAX 2400 // This is the rounded &#39;maximum&#39; microsecond length based on the maximum pulse of 600 #define SERVO_FREQ 50 // Analog servos run at ~50 Hz updates // our servo # counter uint8_t servonum = 0; void setup() { Serial.begin(9600); Serial.println(&#34;8 channel Servo test!&#34;); pwm.begin(); /* * In theory the internal oscillator (clock) is 25MHz but it really isn&#39;t * that precise. You can &#39;calibrate&#39; this by tweaking this number until * you get the PWM update frequency you&#39;re expecting! * The int.osc. for the PCA9685 chip is a range between about 23-27MHz and * is used for calculating things like writeMicroseconds() * Analog servos run at ~50 Hz updates, It is importaint to use an * oscilloscope in setting the int.osc frequency for the I2C PCA9685 chip. * 1) Attach the oscilloscope to one of the PWM signal pins and ground on * the I2C PCA9685 chip you are setting the value for. * 2) Adjust setOscillatorFrequency() until the PWM update frequency is the * expected value (50Hz for most ESCs) * Setting the value here is specific to each individual I2C PCA9685 chip and * affects the calculations for the PWM update frequency. * Failure to correctly set the int.osc value will cause unexpected PWM results */ pwm.setOscillatorFrequency(27000000); pwm.setPWMFreq(SERVO_FREQ); // Analog servos run at ~50 Hz updates delay(10); } // You can use this function if you&#39;d like to set the pulse length in seconds // e.g. setServoPulse(0, 0.001) is a ~1 millisecond pulse width. It&#39;s not precise! void setServoPulse(uint8_t n, double pulse) { double pulselength; pulselength = 1000000; // 1,000,000 us per second pulselength /= SERVO_FREQ; // Analog servos run at ~60 Hz updates Serial.print(pulselength); Serial.println(&#34; us per period&#34;); pulselength /= 4096; // 12 bits of resolution Serial.print(pulselength); Serial.println(&#34; us per bit&#34;); pulse *= 1000000; // convert input seconds to us pulse /= pulselength; Serial.println(pulse); pwm.setPWM(n, 0, pulse); } void loop() { // Drive each servo one at a time using setPWM() Serial.println(servonum); for (uint16_t pulselen = SERVOMIN; pulselen &lt; SERVOMAX; pulselen&#43;&#43;) { pwm.setPWM(servonum, 0, pulselen); } delay(500); for (uint16_t pulselen = SERVOMAX; pulselen &gt; SERVOMIN; pulselen--) { pwm.setPWM(servonum, 0, pulselen); } delay(500); // Drive each servo one at a time using writeMicroseconds(), it&#39;s not precise due to calculation rounding! // The writeMicroseconds() function is used to mimic the Arduino Servo library writeMicroseconds() behavior. for (uint16_t microsec = USMIN; microsec &lt; USMAX; microsec&#43;&#43;) { pwm.writeMicroseconds(servonum, microsec); } delay(500); for (uint16_t microsec = USMAX; microsec &gt; USMIN; microsec--) { pwm.writeMicroseconds(servonum, microsec); } delay(500); servonum&#43;&#43;; if (servonum &gt; 7) servonum = 0; // Testing the first 8 servo channels }Usage examples# // 1. Define the &#34;Pins&#34; (Channels) const uint8_t BASE = 0; const uint8_t ELBOW = 1; const uint8_t WRIST = 2; const uint8_t CLAW = 3; // 2. Put them in an array so the loop knows which ones to talk to uint8_t myServos[] = {BASE, ELBOW, WRIST, CLAW}; int totalServos = 4; void setup() { pwm.begin(); pwm.setPWMFreq(60); } void loop() { // 3. Loop through the array for (int i = 0; i &lt; totalServos; i&#43;&#43;) { uint8_t currentPin = myServos[i]; // This pulls 0, then 1, then 2... // Command the specific pin pwm.setPWM(currentPin, 0, 300); delay(200); }void loop() { // Move the base to 90 degrees setServoAngle(BASE_SERVO, 90); // Open the claw setServoAngle(CLAW_SERVO, 10); delay(1000); // Close the claw setServoAngle(CLAW_SERVO, 170); delay(1000); } // Helper function to handle the degree-to-pulse math void setServoAngle(uint8_t channel, int angle) { uint16_t pulse = map(angle, 0, 180, SERVOMIN, SERVOMAX); pwm.setPWM(channel, 0, pulse); }">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/2025-2026/biosensor/adafruit-pca9685-pwm/">
  <meta property="og:site_name" content="ASTRA Notes">
  <meta property="og:title" content="Adafruit PCA9685 PWM">
  <meta property="og:description" content="Snippets# Adafruit example# From: Adafruit GitHub
/*************************************************** This is an example for our Adafruit 16-channel PWM &amp; Servo driver Servo test - this will drive 8 servos, one after the other on the first 8 pins of the PCA9685 Pick one up today in the adafruit shop! ------&gt; http://www.adafruit.com/products/815 These drivers use I2C to communicate, 2 pins are required to interface. Adafruit invests time and resources providing this open source code, please support Adafruit and open-source hardware by purchasing products from Adafruit! Written by Limor Fried/Ladyada for Adafruit Industries. BSD license, all text above must be included in any redistribution ****************************************************/ #include &lt;Wire.h&gt; #include &lt;Adafruit_PWMServoDriver.h&gt; // called this way, it uses the default address 0x40 Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(); // you can also call it with a different address you want //Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x41); // you can also call it with a different address and I2C interface //Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x40, Wire); // Depending on your servo make, the pulse width min and max may vary, you // want these to be as small/large as possible without hitting the hard stop // for max range. You&#39;ll have to tweak them as necessary to match the servos you // have! #define SERVOMIN 150 // This is the &#39;minimum&#39; pulse length count (out of 4096) #define SERVOMAX 600 // This is the &#39;maximum&#39; pulse length count (out of 4096) #define USMIN 600 // This is the rounded &#39;minimum&#39; microsecond length based on the minimum pulse of 150 #define USMAX 2400 // This is the rounded &#39;maximum&#39; microsecond length based on the maximum pulse of 600 #define SERVO_FREQ 50 // Analog servos run at ~50 Hz updates // our servo # counter uint8_t servonum = 0; void setup() { Serial.begin(9600); Serial.println(&#34;8 channel Servo test!&#34;); pwm.begin(); /* * In theory the internal oscillator (clock) is 25MHz but it really isn&#39;t * that precise. You can &#39;calibrate&#39; this by tweaking this number until * you get the PWM update frequency you&#39;re expecting! * The int.osc. for the PCA9685 chip is a range between about 23-27MHz and * is used for calculating things like writeMicroseconds() * Analog servos run at ~50 Hz updates, It is importaint to use an * oscilloscope in setting the int.osc frequency for the I2C PCA9685 chip. * 1) Attach the oscilloscope to one of the PWM signal pins and ground on * the I2C PCA9685 chip you are setting the value for. * 2) Adjust setOscillatorFrequency() until the PWM update frequency is the * expected value (50Hz for most ESCs) * Setting the value here is specific to each individual I2C PCA9685 chip and * affects the calculations for the PWM update frequency. * Failure to correctly set the int.osc value will cause unexpected PWM results */ pwm.setOscillatorFrequency(27000000); pwm.setPWMFreq(SERVO_FREQ); // Analog servos run at ~50 Hz updates delay(10); } // You can use this function if you&#39;d like to set the pulse length in seconds // e.g. setServoPulse(0, 0.001) is a ~1 millisecond pulse width. It&#39;s not precise! void setServoPulse(uint8_t n, double pulse) { double pulselength; pulselength = 1000000; // 1,000,000 us per second pulselength /= SERVO_FREQ; // Analog servos run at ~60 Hz updates Serial.print(pulselength); Serial.println(&#34; us per period&#34;); pulselength /= 4096; // 12 bits of resolution Serial.print(pulselength); Serial.println(&#34; us per bit&#34;); pulse *= 1000000; // convert input seconds to us pulse /= pulselength; Serial.println(pulse); pwm.setPWM(n, 0, pulse); } void loop() { // Drive each servo one at a time using setPWM() Serial.println(servonum); for (uint16_t pulselen = SERVOMIN; pulselen &lt; SERVOMAX; pulselen&#43;&#43;) { pwm.setPWM(servonum, 0, pulselen); } delay(500); for (uint16_t pulselen = SERVOMAX; pulselen &gt; SERVOMIN; pulselen--) { pwm.setPWM(servonum, 0, pulselen); } delay(500); // Drive each servo one at a time using writeMicroseconds(), it&#39;s not precise due to calculation rounding! // The writeMicroseconds() function is used to mimic the Arduino Servo library writeMicroseconds() behavior. for (uint16_t microsec = USMIN; microsec &lt; USMAX; microsec&#43;&#43;) { pwm.writeMicroseconds(servonum, microsec); } delay(500); for (uint16_t microsec = USMAX; microsec &gt; USMIN; microsec--) { pwm.writeMicroseconds(servonum, microsec); } delay(500); servonum&#43;&#43;; if (servonum &gt; 7) servonum = 0; // Testing the first 8 servo channels }Usage examples# // 1. Define the &#34;Pins&#34; (Channels) const uint8_t BASE = 0; const uint8_t ELBOW = 1; const uint8_t WRIST = 2; const uint8_t CLAW = 3; // 2. Put them in an array so the loop knows which ones to talk to uint8_t myServos[] = {BASE, ELBOW, WRIST, CLAW}; int totalServos = 4; void setup() { pwm.begin(); pwm.setPWMFreq(60); } void loop() { // 3. Loop through the array for (int i = 0; i &lt; totalServos; i&#43;&#43;) { uint8_t currentPin = myServos[i]; // This pulls 0, then 1, then 2... // Command the specific pin pwm.setPWM(currentPin, 0, 300); delay(200); }void loop() { // Move the base to 90 degrees setServoAngle(BASE_SERVO, 90); // Open the claw setServoAngle(CLAW_SERVO, 10); delay(1000); // Close the claw setServoAngle(CLAW_SERVO, 170); delay(1000); } // Helper function to handle the degree-to-pulse math void setServoAngle(uint8_t channel, int angle) { uint16_t pulse = map(angle, 0, 180, SERVOMIN, SERVOMAX); pwm.setPWM(channel, 0, pulse); }">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">


  <meta itemprop="name" content="Adafruit PCA9685 PWM">
  <meta itemprop="description" content="Snippets# Adafruit example# From: Adafruit GitHub
/*************************************************** This is an example for our Adafruit 16-channel PWM &amp; Servo driver Servo test - this will drive 8 servos, one after the other on the first 8 pins of the PCA9685 Pick one up today in the adafruit shop! ------&gt; http://www.adafruit.com/products/815 These drivers use I2C to communicate, 2 pins are required to interface. Adafruit invests time and resources providing this open source code, please support Adafruit and open-source hardware by purchasing products from Adafruit! Written by Limor Fried/Ladyada for Adafruit Industries. BSD license, all text above must be included in any redistribution ****************************************************/ #include &lt;Wire.h&gt; #include &lt;Adafruit_PWMServoDriver.h&gt; // called this way, it uses the default address 0x40 Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(); // you can also call it with a different address you want //Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x41); // you can also call it with a different address and I2C interface //Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x40, Wire); // Depending on your servo make, the pulse width min and max may vary, you // want these to be as small/large as possible without hitting the hard stop // for max range. You&#39;ll have to tweak them as necessary to match the servos you // have! #define SERVOMIN 150 // This is the &#39;minimum&#39; pulse length count (out of 4096) #define SERVOMAX 600 // This is the &#39;maximum&#39; pulse length count (out of 4096) #define USMIN 600 // This is the rounded &#39;minimum&#39; microsecond length based on the minimum pulse of 150 #define USMAX 2400 // This is the rounded &#39;maximum&#39; microsecond length based on the maximum pulse of 600 #define SERVO_FREQ 50 // Analog servos run at ~50 Hz updates // our servo # counter uint8_t servonum = 0; void setup() { Serial.begin(9600); Serial.println(&#34;8 channel Servo test!&#34;); pwm.begin(); /* * In theory the internal oscillator (clock) is 25MHz but it really isn&#39;t * that precise. You can &#39;calibrate&#39; this by tweaking this number until * you get the PWM update frequency you&#39;re expecting! * The int.osc. for the PCA9685 chip is a range between about 23-27MHz and * is used for calculating things like writeMicroseconds() * Analog servos run at ~50 Hz updates, It is importaint to use an * oscilloscope in setting the int.osc frequency for the I2C PCA9685 chip. * 1) Attach the oscilloscope to one of the PWM signal pins and ground on * the I2C PCA9685 chip you are setting the value for. * 2) Adjust setOscillatorFrequency() until the PWM update frequency is the * expected value (50Hz for most ESCs) * Setting the value here is specific to each individual I2C PCA9685 chip and * affects the calculations for the PWM update frequency. * Failure to correctly set the int.osc value will cause unexpected PWM results */ pwm.setOscillatorFrequency(27000000); pwm.setPWMFreq(SERVO_FREQ); // Analog servos run at ~50 Hz updates delay(10); } // You can use this function if you&#39;d like to set the pulse length in seconds // e.g. setServoPulse(0, 0.001) is a ~1 millisecond pulse width. It&#39;s not precise! void setServoPulse(uint8_t n, double pulse) { double pulselength; pulselength = 1000000; // 1,000,000 us per second pulselength /= SERVO_FREQ; // Analog servos run at ~60 Hz updates Serial.print(pulselength); Serial.println(&#34; us per period&#34;); pulselength /= 4096; // 12 bits of resolution Serial.print(pulselength); Serial.println(&#34; us per bit&#34;); pulse *= 1000000; // convert input seconds to us pulse /= pulselength; Serial.println(pulse); pwm.setPWM(n, 0, pulse); } void loop() { // Drive each servo one at a time using setPWM() Serial.println(servonum); for (uint16_t pulselen = SERVOMIN; pulselen &lt; SERVOMAX; pulselen&#43;&#43;) { pwm.setPWM(servonum, 0, pulselen); } delay(500); for (uint16_t pulselen = SERVOMAX; pulselen &gt; SERVOMIN; pulselen--) { pwm.setPWM(servonum, 0, pulselen); } delay(500); // Drive each servo one at a time using writeMicroseconds(), it&#39;s not precise due to calculation rounding! // The writeMicroseconds() function is used to mimic the Arduino Servo library writeMicroseconds() behavior. for (uint16_t microsec = USMIN; microsec &lt; USMAX; microsec&#43;&#43;) { pwm.writeMicroseconds(servonum, microsec); } delay(500); for (uint16_t microsec = USMAX; microsec &gt; USMIN; microsec--) { pwm.writeMicroseconds(servonum, microsec); } delay(500); servonum&#43;&#43;; if (servonum &gt; 7) servonum = 0; // Testing the first 8 servo channels }Usage examples# // 1. Define the &#34;Pins&#34; (Channels) const uint8_t BASE = 0; const uint8_t ELBOW = 1; const uint8_t WRIST = 2; const uint8_t CLAW = 3; // 2. Put them in an array so the loop knows which ones to talk to uint8_t myServos[] = {BASE, ELBOW, WRIST, CLAW}; int totalServos = 4; void setup() { pwm.begin(); pwm.setPWMFreq(60); } void loop() { // 3. Loop through the array for (int i = 0; i &lt; totalServos; i&#43;&#43;) { uint8_t currentPin = myServos[i]; // This pulls 0, then 1, then 2... // Command the specific pin pwm.setPWM(currentPin, 0, 300); delay(200); }void loop() { // Move the base to 90 degrees setServoAngle(BASE_SERVO, 90); // Open the claw setServoAngle(CLAW_SERVO, 10); delay(1000); // Close the claw setServoAngle(CLAW_SERVO, 170); delay(1000); } // Helper function to handle the degree-to-pulse math void setServoAngle(uint8_t channel, int angle) { uint16_t pulse = map(angle, 0, 180, SERVOMIN, SERVOMAX); pwm.setPWM(channel, 0, pulse); }">
  <meta itemprop="wordCount" content="832">

<title>Adafruit PCA9685 PWM | ASTRA Notes</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/docs/2025-2026/biosensor/adafruit-pca9685-pwm/">
<link rel="stylesheet" href="/book.min.6970156cec683193d93c9c4edaf0d56574e4361df2e0c1be4f697ae81c3ba55f.css" integrity="sha256-aXAVbOxoMZPZPJxO2vDVZXTkNh3y4MG&#43;T2l66Bw7pV8=" crossorigin="anonymous">


  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.b17916bf505e2a2a5eae0268ec865dd80019f1dc1ff9645d4820d3600716e9e3.js" integrity="sha256-sXkWv1BeKipergJo7IZd2AAZ8dwf&#43;WRdSCDTYAcW6eM=" crossorigin="anonymous"></script>



  
</head>
<body dir="ltr" class="book-kind-page book-type-docs">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>ASTRA Notes</span>
  </a>
</h2>


<div class="book-search hidden">
  <input id="book-search-input" type="text" 
    placeholder="Search"
    aria-label="Search"
    maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>













  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9224885e9f42840aad20e7ea30740f65" class="toggle" checked />
    <label for="section-9224885e9f42840aad20e7ea30740f65" class="flex">
      <a role="button" class="">
        2025-2026</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-415908d1a8e7f76faa9934d3b4525eb1" class="toggle" checked />
    <label for="section-415908d1a8e7f76faa9934d3b4525eb1" class="flex">
      <a role="button" class="">
        Biosensor</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/2025-2026/biosensor/2025-bio-code/" class="">
      2025 Biosensor Code</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/2025-2026/biosensor/adafruit-pca9685-pwm/" class="active">
      Adafruit PCA9685 PWM</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/2025-2026/biosensor/can-commands/" class="">
      CAN commands</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/2025-2026/biosensor/embedded-summary/" class="">
      Embedded summary</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-82d6151fc137eeca2b5cf82cc58d6f46" class="toggle"  />
    <label for="section-82d6151fc137eeca2b5cf82cc58d6f46" class="flex">
      <a role="button" class="">
        Prototypes</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/2025-2026/biosensor/prototypes/esp32s3/" class="">
      ESP32-S3</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-71fdf0830a0069cb9c89fa2e0e6d340c" class="toggle"  />
    <label for="section-71fdf0830a0069cb9c89fa2e0e6d340c" class="flex">
      <a role="button" class="">
        Meetings</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/2025-2026/meetings/1-13-26/" class="">
      1-13-26</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/2025-2026/meetings/1-7-26/" class="">
      1-7-26</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-00e7e1442ae5cfc4332287e524ecfcdf" class="toggle"  />
    <label for="section-00e7e1442ae5cfc4332287e524ecfcdf" class="flex">
      <a role="button" class="">
        Example</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-85dc96621d713e3a8ff3061bb7122de2" class="toggle"  />
    <label for="section-85dc96621d713e3a8ff3061bb7122de2" class="flex">
      <a role="button" class="">
        Embedded</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/embedded/serial-command-parser/" class="">
      Serial Command Parser</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6f7ee745eb01d60701d2583e6db10b65" class="toggle"  />
    <label for="section-6f7ee745eb01d60701d2583e6db10b65" class="flex">
      <a role="button" class="">
        Two-Month</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-360805aae7753d6b7710722836f98c54" class="toggle"  />
    <label for="section-360805aae7753d6b7710722836f98c54" class="flex">
      <a role="button" class="">
        ROS2</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/two-month/ros2/about-ros/" class="">
      About ROS</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/two-month/ros2/installing-ros2-humble/" class="">
      Installing ROS2 Humble</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-ae7b997217ccb24c3ec50c90090ea0b5" class="toggle"  />
    <label for="section-ae7b997217ccb24c3ec50c90090ea0b5" class="flex">
      <a role="button" class="">
        Sensors</a>
      <img src="/icons/chevron-right.svg" class="book-icon" alt="Expand" />
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/two-month/sensors/working-with-the-bnp3xx/" class="">
      Working with the BMP388</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/two-month/sensors/working-with-the-bno055/" class="">
      Working with the BNO055</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/two-month/resources/" class="">
      Resources</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>













</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header hidden">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/icons/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Adafruit PCA9685 PWM</h3>

  <label for="toc-control">
    
    <img src="/icons/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#adafruit-example">Adafruit example</a></li>
    <li><a href="#usage-examples">Usage examples</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="snippets">Snippets<a class="anchor" href="#snippets">#</a></h1>
<h2 id="adafruit-example">Adafruit example<a class="anchor" href="#adafruit-example">#</a></h2>
<p>From: <a href="https://github.com/adafruit/Adafruit-PWM-Servo-Driver-Library/blob/master/examples/servo/servo.ino">Adafruit GitHub</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">/*************************************************** 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  This is an example for our Adafruit 16-channel PWM &amp; Servo driver
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  Servo test - this will drive 8 servos, one after the other on the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  first 8 pins of the PCA9685
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  Pick one up today in the adafruit shop!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  ------&gt; http://www.adafruit.com/products/815
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  These drivers use I2C to communicate, 2 pins are required to  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  interface.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  Adafruit invests time and resources providing this open source code, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  please support Adafruit and open-source hardware by purchasing 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  products from Adafruit!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  Written by Limor Fried/Ladyada for Adafruit Industries.  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  BSD license, all text above must be included in any redistribution
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> ****************************************************/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Wire.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;Adafruit_PWMServoDriver.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// called this way, it uses the default address 0x40
</span></span></span><span style="display:flex;"><span>Adafruit_PWMServoDriver pwm <span style="color:#f92672">=</span> Adafruit_PWMServoDriver();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// you can also call it with a different address you want
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x41);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// you can also call it with a different address and I2C interface
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(0x40, Wire);
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Depending on your servo make, the pulse width min and max may vary, you 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// want these to be as small/large as possible without hitting the hard stop
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// for max range. You&#39;ll have to tweak them as necessary to match the servos you
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// have!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define SERVOMIN  150 </span><span style="color:#75715e">// This is the &#39;minimum&#39; pulse length count (out of 4096)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define SERVOMAX  600 </span><span style="color:#75715e">// This is the &#39;maximum&#39; pulse length count (out of 4096)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define USMIN  600 </span><span style="color:#75715e">// This is the rounded &#39;minimum&#39; microsecond length based on the minimum pulse of 150
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define USMAX  2400 </span><span style="color:#75715e">// This is the rounded &#39;maximum&#39; microsecond length based on the maximum pulse of 600
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define SERVO_FREQ 50 </span><span style="color:#75715e">// Analog servos run at ~50 Hz updates
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// our servo # counter
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint8_t</span> servonum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setup</span>() {
</span></span><span style="display:flex;"><span>  Serial.begin(<span style="color:#ae81ff">9600</span>);
</span></span><span style="display:flex;"><span>  Serial.println(<span style="color:#e6db74">&#34;8 channel Servo test!&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  pwm.begin();
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * In theory the internal oscillator (clock) is 25MHz but it really isn&#39;t
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * that precise. You can &#39;calibrate&#39; this by tweaking this number until
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * you get the PWM update frequency you&#39;re expecting!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * The int.osc. for the PCA9685 chip is a range between about 23-27MHz and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * is used for calculating things like writeMicroseconds()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * Analog servos run at ~50 Hz updates, It is importaint to use an
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * oscilloscope in setting the int.osc frequency for the I2C PCA9685 chip.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * 1) Attach the oscilloscope to one of the PWM signal pins and ground on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   *    the I2C PCA9685 chip you are setting the value for.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * 2) Adjust setOscillatorFrequency() until the PWM update frequency is the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   *    expected value (50Hz for most ESCs)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * Setting the value here is specific to each individual I2C PCA9685 chip and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * affects the calculations for the PWM update frequency. 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   * Failure to correctly set the int.osc value will cause unexpected PWM results
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">   */</span>
</span></span><span style="display:flex;"><span>  pwm.setOscillatorFrequency(<span style="color:#ae81ff">27000000</span>);
</span></span><span style="display:flex;"><span>  pwm.setPWMFreq(SERVO_FREQ);  <span style="color:#75715e">// Analog servos run at ~50 Hz updates
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  delay(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// You can use this function if you&#39;d like to set the pulse length in seconds
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// e.g. setServoPulse(0, 0.001) is a ~1 millisecond pulse width. It&#39;s not precise!
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setServoPulse</span>(<span style="color:#66d9ef">uint8_t</span> n, <span style="color:#66d9ef">double</span> pulse) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">double</span> pulselength;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  pulselength <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000</span>;   <span style="color:#75715e">// 1,000,000 us per second
</span></span></span><span style="display:flex;"><span>  pulselength <span style="color:#f92672">/=</span> SERVO_FREQ;   <span style="color:#75715e">// Analog servos run at ~60 Hz updates
</span></span></span><span style="display:flex;"><span>  Serial.print(pulselength); Serial.println(<span style="color:#e6db74">&#34; us per period&#34;</span>); 
</span></span><span style="display:flex;"><span>  pulselength <span style="color:#f92672">/=</span> <span style="color:#ae81ff">4096</span>;  <span style="color:#75715e">// 12 bits of resolution
</span></span></span><span style="display:flex;"><span>  Serial.print(pulselength); Serial.println(<span style="color:#e6db74">&#34; us per bit&#34;</span>); 
</span></span><span style="display:flex;"><span>  pulse <span style="color:#f92672">*=</span> <span style="color:#ae81ff">1000000</span>;  <span style="color:#75715e">// convert input seconds to us
</span></span></span><span style="display:flex;"><span>  pulse <span style="color:#f92672">/=</span> pulselength;
</span></span><span style="display:flex;"><span>  Serial.println(pulse);
</span></span><span style="display:flex;"><span>  pwm.setPWM(n, <span style="color:#ae81ff">0</span>, pulse);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">loop</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Drive each servo one at a time using setPWM()
</span></span></span><span style="display:flex;"><span>  Serial.println(servonum);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint16_t</span> pulselen <span style="color:#f92672">=</span> SERVOMIN; pulselen <span style="color:#f92672">&lt;</span> SERVOMAX; pulselen<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    pwm.setPWM(servonum, <span style="color:#ae81ff">0</span>, pulselen);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  delay(<span style="color:#ae81ff">500</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint16_t</span> pulselen <span style="color:#f92672">=</span> SERVOMAX; pulselen <span style="color:#f92672">&gt;</span> SERVOMIN; pulselen<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>    pwm.setPWM(servonum, <span style="color:#ae81ff">0</span>, pulselen);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  delay(<span style="color:#ae81ff">500</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Drive each servo one at a time using writeMicroseconds(), it&#39;s not precise due to calculation rounding!
</span></span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The writeMicroseconds() function is used to mimic the Arduino Servo library writeMicroseconds() behavior. 
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint16_t</span> microsec <span style="color:#f92672">=</span> USMIN; microsec <span style="color:#f92672">&lt;</span> USMAX; microsec<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    pwm.writeMicroseconds(servonum, microsec);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  delay(<span style="color:#ae81ff">500</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint16_t</span> microsec <span style="color:#f92672">=</span> USMAX; microsec <span style="color:#f92672">&gt;</span> USMIN; microsec<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>    pwm.writeMicroseconds(servonum, microsec);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  delay(<span style="color:#ae81ff">500</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  servonum<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (servonum <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">7</span>) servonum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Testing the first 8 servo channels
</span></span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h2 id="usage-examples">Usage examples<a class="anchor" href="#usage-examples">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 1. Define the &#34;Pins&#34; (Channels)
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span> BASE   <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span> ELBOW  <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span> WRIST  <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span> CLAW   <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 2. Put them in an array so the loop knows which ones to talk to
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint8_t</span> myServos[] <span style="color:#f92672">=</span> {BASE, ELBOW, WRIST, CLAW};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> totalServos <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setup</span>() {
</span></span><span style="display:flex;"><span>  pwm.begin();
</span></span><span style="display:flex;"><span>  pwm.setPWMFreq(<span style="color:#ae81ff">60</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">loop</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 3. Loop through the array
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> totalServos; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> currentPin <span style="color:#f92672">=</span> myServos[i]; <span style="color:#75715e">// This pulls 0, then 1, then 2...
</span></span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Command the specific pin
</span></span></span><span style="display:flex;"><span>    pwm.setPWM(currentPin, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">300</span>); 
</span></span><span style="display:flex;"><span>    delay(<span style="color:#ae81ff">200</span>);
</span></span><span style="display:flex;"><span>  }</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">loop</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Move the base to 90 degrees
</span></span></span><span style="display:flex;"><span>  setServoAngle(BASE_SERVO, <span style="color:#ae81ff">90</span>);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Open the claw
</span></span></span><span style="display:flex;"><span>  setServoAngle(CLAW_SERVO, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>  delay(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Close the claw
</span></span></span><span style="display:flex;"><span>  setServoAngle(CLAW_SERVO, <span style="color:#ae81ff">170</span>);
</span></span><span style="display:flex;"><span>  delay(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Helper function to handle the degree-to-pulse math
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setServoAngle</span>(<span style="color:#66d9ef">uint8_t</span> channel, <span style="color:#66d9ef">int</span> angle) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint16_t</span> pulse <span style="color:#f92672">=</span> map(angle, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">180</span>, SERVOMIN, SERVOMAX);
</span></span><span style="display:flex;"><span>  pwm.setPWM(channel, <span style="color:#ae81ff">0</span>, pulse);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">

<div>

</div>

<div>

</div>

</div>





  
  
  
  <div class="flex flex-wrap justify-between">
    <span>
    
      <a href="/docs/2025-2026/biosensor/2025-bio-code/" class="flex align-center">
        <img src="/icons/backward.svg" class="book-icon" alt="Backward" />
        <span>2025 Biosensor Code</span>
      </a>
    
    </span>
    <span>
    
      <a href="/docs/2025-2026/biosensor/can-commands/" class="flex align-center">
        <span>CAN commands</span>
        <img src="/icons/forward.svg" class="book-icon" alt="Forward" />
      </a>
    
    </span>
  </div>
  


 
        
  
  <div class="book-comments">

</div>
  
 
        
        
  
 
        
  
  
    <script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script>
  

      </footer>

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  
  <aside class="book-toc">
    <div class="book-toc-content">
      
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#adafruit-example">Adafruit example</a></li>
    <li><a href="#usage-examples">Usage examples</a></li>
  </ul>
</nav>



    </div>
  </aside>
  
 
  </main>

  
</body>
</html>




















